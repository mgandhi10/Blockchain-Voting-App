// SPDX-License-Identifier: UNLICENSED
pragma experimental ABIEncoderV2;
pragma solidity >=0.8.0 <0.9.0;

contract theVotingContract {
    
    struct Candidate {
        uint id;
        string name;
        uint voteCount;
    }

    struct Poll {
        string id;
        string description;
        mapping(uint => Candidate) candidates;
        uint candidatesCount;
        mapping(address => bool) hasVoted; // Track if a voter has voted
        mapping(address => bool) admins;
        address creator;
    }

    mapping(string => Poll) public polls;
    uint256 private nonce = 0; // Counter to ensure different values

    event PollCreated(string indexed pollId);
    event CandidateAdded(string indexed pollId, uint indexed candidateId);
    event Voted(string indexed pollId, uint indexed candidateId);

    function createPoll(string memory _description) public returns (string memory) {
        string memory randomId = generateRandomId(5);

        // Ensure unique ID
        while (bytes(polls[randomId].description).length != 0) {
            randomId = generateRandomId(5);
        }

        Poll storage newPoll = polls[randomId];
        newPoll.id = randomId;
        newPoll.description = _description;
        newPoll.creator = msg.sender;
        newPoll.admins[msg.sender] = true;
        emit PollCreated(randomId);

        return randomId;
    }

    function addCandidate(string memory _pollId, string memory _name) public {
        require(polls[_pollId].admins[msg.sender], "Only admins can add candidates");
        Poll storage poll = polls[_pollId];
        poll.candidatesCount++;
        poll.candidates[poll.candidatesCount] = Candidate(poll.candidatesCount, _name, 0);
        emit CandidateAdded(_pollId, poll.candidatesCount);
    }

    function assignAdmin(string memory _pollId, address _admin) public {
        require(polls[_pollId].creator == msg.sender, "Only the poll creator can assign admins");
        polls[_pollId].admins[_admin] = true;
    }

    function vote(string memory _pollId, uint _candidateId) public {
        require(bytes(polls[_pollId].description).length != 0, "Invalid poll ID");
        require(_candidateId > 0 && _candidateId <= polls[_pollId].candidatesCount, "Invalid candidate ID");
        require(!polls[_pollId].hasVoted[msg.sender], "Voter has already voted in this poll");
        
        Poll storage poll = polls[_pollId];
        poll.candidates[_candidateId].voteCount++;
        poll.hasVoted[msg.sender] = true;
        emit Voted(_pollId, _candidateId);
    }

    function getPollCandidates(string memory _pollId) public view returns (Candidate[] memory) {
        Candidate[] memory candidatesArray = new Candidate[](polls[_pollId].candidatesCount);
        for (uint i = 1; i <= polls[_pollId].candidatesCount; i++) {
            candidatesArray[i - 1] = polls[_pollId].candidates[i];
        }
        return candidatesArray;
    }

    function generateRandomId(uint length) internal view returns (string memory) {
        bytes memory charset = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        bytes memory randomString = new bytes(length);

        for (uint i = 0; i < length; i++) {
            uint rand = uint(keccak256(abi.encodePacked(block.timestamp, msg.sender, nonce, i))) % charset.length;
            randomString[i] = charset[rand];
        }

        return string(randomString);
    }

    function getPollDetails(string memory _pollId) public view returns (string memory, string memory, Candidate[] memory) {
        require(bytes(polls[_pollId].description).length != 0, "Poll does not exist");

        Poll storage poll = polls[_pollId];
        Candidate[] memory candidatesArray = new Candidate[](poll.candidatesCount);

        for (uint i = 1; i <= poll.candidatesCount; i++) {
            candidatesArray[i - 1] = poll.candidates[i];
        }

        return (poll.id, poll.description, candidatesArray);
    }
}
